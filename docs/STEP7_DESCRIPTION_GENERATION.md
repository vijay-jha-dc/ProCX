# üîç Step 7 Deep Dive: Description Generation & Multi-Sheet Data Mapping

## Your Questions

1. **On step 7, how and on what basis will it generate intervention descriptions?**
2. **What exactly is the 7th step, is it diff from the prev description?**
3. **Our datasheet should have description.**
4. **How are you able to map and fetch all the data from multiple sheets for that specific customer?**
5. **Where does all the comparison with different customers is stored or processed?**

---

## üìã Step 7 Explained: "Generate Intervention Descriptions"

### What It Does

Step 7 takes the **health analysis results** (from steps 1-6) and creates a **human-readable description** that will be sent to the **AI agents** for processing.

### Two Types of Descriptions - THIS IS KEY!

#### Type 1: Initial Problem Description (Step 7) ‚Üê **THIS IS WHAT STEP 7 GENERATES**

**Purpose:** Summarize the customer's health issue for AI agents to understand
**Generated by:** `_create_proactive_event()` method in `main.py` line 204
**Used for:** Input to the agent pipeline

**Example:**

```
VIP customer at high risk (LTV: $45,230.50)
‚Ä¢ Health Score: 58/100 (Warning)
‚Ä¢ Churn Risk: 68%
‚Ä¢ Risk Factors: Low health score, High-value segment at risk, Below-average in cohort
‚Ä¢ Recommended Action: Immediate Personal Outreach
```

#### Type 2: Final Customer Response (Step 9) ‚Üê **THIS IS DIFFERENT**

**Purpose:** The actual message to send to the customer
**Generated by:** Empathy Agent (GPT-4) in the agent pipeline
**Used for:** Email/SMS to customer

**Example:**

```
Dear Rajesh,

Thank you for being a valued VIP member. We've noticed you haven't placed
an order recently and wanted to reach out personally.

We'd love to offer you an exclusive 20% discount on your next purchase...
```

### So YES - Step 7 Description is Different!

| Aspect           | Step 7 (Problem Description) | Step 9 (Customer Response) |
| ---------------- | ---------------------------- | -------------------------- |
| **Audience**     | AI agents                    | Customer                   |
| **Tone**         | Technical/analytical         | Empathetic/personalized    |
| **Content**      | Health scores, risk factors  | Solution, offer, support   |
| **Generated by** | ProCX system logic           | GPT-4 Empathy Agent        |
| **Purpose**      | Context for AI decision      | Actual outreach message    |

---

## üéØ How Step 7 Generates Description (In Detail)

### Code Location: `main.py` line 204-240

```python
def _create_proactive_event(self, customer, alert):
    """
    This is Step 7 - Generate intervention description
    """
    # INPUT: customer object + alert dictionary
    # OUTPUT: CustomerEvent with description

    # 1. Extract scores from alert (calculated in steps 3-4)
    health_score = alert['health_score'] * 100  # Convert 0.58 ‚Üí 58
    churn_risk = alert['churn_risk'] * 100      # Convert 0.68 ‚Üí 68

    # 2. Determine health status (business logic)
    if health_score < 40:
        health_status = "CRITICAL"
    elif health_score < 60:
        health_status = "Warning"
    else:
        health_status = "Concerning"

    # 3. Build description (THIS IS THE GENERATION STEP)
    description = f"""{customer.segment} customer at high risk (LTV: ${customer.lifetime_value:,.2f})
‚Ä¢ Health Score: {health_score:.0f}/100 ({health_status})
‚Ä¢ Churn Risk: {churn_risk:.0f}%
‚Ä¢ Risk Factors: {', '.join(alert['reasons'][:3])}
‚Ä¢ Recommended Action: {alert['recommended_action'].replace('_', ' ').title()}"""

    # 4. Package into CustomerEvent
    return CustomerEvent(
        event_id=f"PROACTIVE_{customer.customer_id}_{timestamp}",
        customer=customer,
        description=description,  # ‚Üê This goes to agents
        metadata={...}
    )
```

### What Basis Does It Use?

The description is generated based on:

1. **Customer Profile** (from `customers` sheet):
   - `customer.segment` ‚Üí "VIP", "Loyal", etc.
   - `customer.lifetime_value` ‚Üí Dollar amount
2. **Health Analysis** (calculated in steps 3-4):

   - `alert['health_score']` ‚Üí 0-1 score (converted to 0-100)
   - `alert['churn_risk']` ‚Üí 0-1 probability
   - `health_status` ‚Üí Logic-based categorization

3. **Risk Factors** (from `alert['reasons']`):

   - Determined in `proactive_monitor.py` line 288-295
   - Based on conditions:
     - Health score < 0.4 ‚Üí "Low health score"
     - Segment = VIP/Loyal ‚Üí "High-value segment at risk"
     - Cohort percentile < 30 ‚Üí "Below-average in cohort"

4. **Recommended Action** (from `alert['recommended_action']`):
   - Determined in `proactive_monitor.py` line 297-304
   - Business logic:
     - VIP ‚Üí "immediate_personal_outreach"
     - LTV > $5000 ‚Üí "retention_offer_premium"
     - Loyal ‚Üí "retention_offer_standard"
     - Other ‚Üí "engagement_campaign"

---

## üìä Question 3: "Our Datasheet Should Have Description"

### ‚ùå NO - Datasheet Does NOT Have Description

**Why?** Because the description is **generated dynamically** based on analysis!

### Data Flow:

```
EXCEL SHEETS (Raw Data)
‚îú‚îÄ‚îÄ customers.xlsx          ‚Üí customer.segment, customer.lifetime_value
‚îú‚îÄ‚îÄ orders.xlsx            ‚Üí order frequency, spending trends
‚îú‚îÄ‚îÄ support_tickets.xlsx   ‚Üí ticket count, response times
‚îú‚îÄ‚îÄ nps_survey.xlsx        ‚Üí satisfaction scores
‚îú‚îÄ‚îÄ payments.xlsx          ‚Üí payment reliability
‚îî‚îÄ‚îÄ churn_labels.xlsx      ‚Üí historical churn patterns

                ‚Üì LOADED INTO MEMORY

DATAFRAMES (In Python)
‚îú‚îÄ‚îÄ self.df (customers)
‚îú‚îÄ‚îÄ self.orders_df
‚îú‚îÄ‚îÄ self.support_tickets_df
‚îú‚îÄ‚îÄ self.nps_survey_df
‚îú‚îÄ‚îÄ self.payments_df
‚îî‚îÄ‚îÄ self.churn_labels_df

                ‚Üì ANALYZED (Steps 1-6)

CALCULATED RESULTS
‚îú‚îÄ‚îÄ health_score (0-100)
‚îú‚îÄ‚îÄ churn_risk (0-100%)
‚îú‚îÄ‚îÄ risk_factors []
‚îî‚îÄ‚îÄ recommended_action

                ‚Üì STEP 7: GENERATION

DESCRIPTION (Auto-Generated)
"VIP customer at high risk (LTV: $45,230.50)
‚Ä¢ Health Score: 58/100 (Warning)
‚Ä¢ Churn Risk: 68%
‚Ä¢ Risk Factors: Low health score, High-value segment at risk
‚Ä¢ Recommended Action: Immediate Personal Outreach"

                ‚Üì STEP 8: AGENT PIPELINE

FINAL MESSAGE (GPT-4 Generated)
"Dear Rajesh, Thank you for being a valued VIP member..."
```

### Key Insight:

- **Raw data** is in Excel sheets
- **Description** is generated by combining and analyzing that raw data
- **No "description" column** in Excel - it's created programmatically!

---

## üó∫Ô∏è Question 4: How We Map & Fetch Data from Multiple Sheets

### The Magic: `customer_id` is the Foreign Key

Every sheet has a `customer_id` column that links to the customer:

```
customers.xlsx
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ customer_id ‚îÇ first_name ‚îÇ segment ‚îÇ   LTV   ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   C100109   ‚îÇ   Rajesh   ‚îÇ   VIP   ‚îÇ 45,230  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        ‚Üì
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                  ‚Üì                  ‚Üì                  ‚Üì
            orders.xlsx      support_tickets.xlsx  nps_survey.xlsx
      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îê
      ‚îÇ customer_id ‚îÇ...‚îÇ   ‚îÇ customer_id ‚îÇ... ‚îÇ  ‚îÇ customer_id ‚îÇ...‚îÇ
      ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚î§   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚î§  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚î§
      ‚îÇ   C100109   ‚îÇ...‚îÇ   ‚îÇ   C100109   ‚îÇ... ‚îÇ  ‚îÇ   C100109   ‚îÇ...‚îÇ
      ‚îÇ   C100109   ‚îÇ...‚îÇ   ‚îÇ   C100109   ‚îÇ... ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îò
      ‚îÇ   C100109   ‚îÇ...‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îò
      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îò
```

### Code Example: `get_customer_order_stats()` in `data_analytics.py` line 702

```python
def get_customer_order_stats(self, customer: Customer) -> Dict[str, Any]:
    """Fetch all orders for a specific customer"""

    # STEP 1: Filter orders_df by customer_id
    customer_orders = self.orders_df[
        self.orders_df['customer_id'] == customer.customer_id
    ]

    # STEP 2: Calculate metrics from filtered data
    total_orders = len(customer_orders)
    avg_amount = customer_orders['total_amount'].mean()

    return {
        'total_orders': total_orders,
        'avg_order_amount': avg_amount
    }
```

### How Pandas Filtering Works:

```python
# Original orders_df (5,000 rows - ALL customers)
orders_df:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ customer_id ‚îÇ order_id ‚îÇ amount ‚îÇ  order_date  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   C100109   ‚îÇ ORD001   ‚îÇ 2500   ‚îÇ 2024-12-01   ‚îÇ
‚îÇ   C100141   ‚îÇ ORD002   ‚îÇ 1200   ‚îÇ 2024-12-02   ‚îÇ
‚îÇ   C100109   ‚îÇ ORD003   ‚îÇ 3400   ‚îÇ 2024-12-15   ‚îÇ
‚îÇ   C100302   ‚îÇ ORD004   ‚îÇ 890    ‚îÇ 2024-12-20   ‚îÇ
‚îÇ   C100109   ‚îÇ ORD005   ‚îÇ 1100   ‚îÇ 2025-01-05   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

# Filter: orders_df['customer_id'] == 'C100109'
customer_orders (3 rows - ONLY C100109):
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ customer_id ‚îÇ order_id ‚îÇ amount ‚îÇ  order_date  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   C100109   ‚îÇ ORD001   ‚îÇ 2500   ‚îÇ 2024-12-01   ‚îÇ
‚îÇ   C100109   ‚îÇ ORD003   ‚îÇ 3400   ‚îÇ 2024-12-15   ‚îÇ
‚îÇ   C100109   ‚îÇ ORD005   ‚îÇ 1100   ‚îÇ 2025-01-05   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

# Then calculate: len(customer_orders) = 3 orders
```

### All Multi-Sheet Fetch Methods:

| Method                               | Sheet Used        | Filters By    | Returns                             |
| ------------------------------------ | ----------------- | ------------- | ----------------------------------- |
| `get_customer_order_stats()`         | `orders`          | `customer_id` | Order count, frequency, amount      |
| `get_customer_support_history()`     | `support_tickets` | `customer_id` | Ticket count, status, response time |
| `get_customer_nps()`                 | `nps_survey`      | `customer_id` | NPS score, feedback                 |
| `get_customer_payment_reliability()` | `payments`        | `customer_id` | Success rate, failed count          |
| `get_actual_churn_status()`          | `churn_labels`    | `customer_id` | Churn status, reason, date          |

### Performance Note:

**Q: "Doesn't this loop through all 5,000 orders for each customer?"**

**A:** Yes, but Pandas is FAST:

- Filtering 5,000 rows takes ~1-5 milliseconds
- We do this for each customer (1,000 customers)
- Total: ~1-5 seconds for all customers
- This is acceptable for a demo!

**Production optimization:** Use SQL database with indexes instead of Excel.

---

## üîÑ Question 5: Where Comparisons Are Stored/Processed

### Answer: IN-MEMORY (Runtime Calculations)

**Nothing is stored permanently!** All comparisons happen in RAM when the program runs.

### Comparison Locations:

#### 1. Cohort Comparison (`compare_with_cohort()`)

**Location:** `data_analytics.py` line 668

```python
def compare_with_cohort(self, customer: Customer) -> Dict[str, Any]:
    """
    Compare customer to their segment (VIP, Loyal, etc.)

    Process:
    1. Filter all customers in same segment
    2. Calculate segment average LTV
    3. Calculate customer's percentile rank
    4. Return comparison results
    """
    # Filter: Get all VIP customers
    cohort = self.df[self.df['segment'] == customer.segment]

    # Calculate: Average LTV of VIPs
    avg_ltv = cohort['lifetime_value'].mean()

    # Calculate: Where does this customer rank?
    percentile = (cohort['lifetime_value'] < customer.lifetime_value).mean() * 100

    # Return: Comparison results (NOT STORED, just returned)
    return {
        'segment': customer.segment,
        'segment_size': len(cohort),
        'segment_avg_ltv': avg_ltv,
        'customer_percentile': percentile  # e.g., 25 = bottom 25%
    }
```

**Storage:** ‚ùå Not stored anywhere, calculated on-demand

#### 2. Similar Customers (`find_similar_customers()`)

**Location:** `data_analytics.py` line 405

```python
def find_similar_customers(self, customer: Customer, limit: int = 10):
    """
    Find customers similar to target customer

    Process:
    1. Loop through ALL customers in df
    2. Calculate similarity score (0-1) for each
    3. Sort by score, return top N
    """
    similar = []

    # Loop through all 1,000 customers
    for _, row in self.df.iterrows():
        # Skip self
        if row['customer_id'] == customer.customer_id:
            continue

        # Calculate similarity
        score = 0.0
        if row['segment'] == customer.segment:
            score += 0.4  # Same segment = +40%

        ltv_diff = abs(row['lifetime_value'] - customer.lifetime_value)
        if ltv_diff < customer.lifetime_value * 0.3:  # Within 30%
            score += 0.3  # Similar LTV = +30%

        if row['preferred_category'] == customer.preferred_category:
            score += 0.2  # Same category = +20%

        if row['loyalty_tier'] == customer.loyalty_tier:
            score += 0.1  # Same tier = +10%

        # Store result
        similar.append({
            'customer_id': row['customer_id'],
            'similarity_score': score,
            'segment': row['segment'],
            'lifetime_value': row['lifetime_value']
        })

    # Sort by score (highest first)
    similar.sort(key=lambda x: x['similarity_score'], reverse=True)

    # Return top N
    return similar[:limit]
```

**Storage:** ‚ùå Not stored, calculated each time needed

#### 3. Health Score Calculation (`calculate_health_score()`)

**Location:** `proactive_monitor.py` line 16

```python
def calculate_health_score(customer: Customer, analytics: DataAnalytics) -> float:
    """
    Calculate 10-factor health score

    Process:
    1. Fetch data from multiple sheets
    2. Calculate each factor (0-1 score)
    3. Sum weighted scores
    4. Return total (0-1)
    """
    score = 0.0

    # Factor 1: Segment (15%)
    if customer.segment == "VIP":
        score += 0.15
    elif customer.segment == "Loyal":
        score += 0.12

    # Factor 2: LTV Percentile (12%)
    cohort = analytics.compare_with_cohort(customer)
    percentile = cohort.get('customer_percentile', 50)
    score += (percentile / 100) * 0.12

    # Factor 5: Activity Recency (15%)
    if customer.days_since_active < 7:
        score += 0.15
    elif customer.days_since_active < 30:
        score += 0.12

    # ... factors 3, 4, 6-10 ...

    return score  # Returns 0.0 to 1.0
```

**Storage:** ‚ùå Not stored, calculated for each customer

### Data Flow Diagram:

```
                      RUNTIME MEMORY
                            ‚îÇ
                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                    ‚îÇ   DataFrames   ‚îÇ
                    ‚îÇ (Loaded Once)  ‚îÇ
                    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
                    ‚îÇ self.df        ‚îÇ ‚Üê customers (1,000 rows)
                    ‚îÇ self.orders_df ‚îÇ ‚Üê orders (5,000 rows)
                    ‚îÇ self.tickets_df‚îÇ ‚Üê tickets (2,000 rows)
                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                             ‚îÇ
              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
              ‚Üì              ‚Üì              ‚Üì
      For Customer 1  For Customer 2  For Customer 3
              ‚îÇ              ‚îÇ              ‚îÇ
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ              ‚îÇ
    ‚îÇ Fetch & Calculate ‚îÇ   ‚îÇ              ‚îÇ
    ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§   ‚îÇ              ‚îÇ
    ‚îÇ Orders: 15        ‚îÇ   ‚îÇ              ‚îÇ
    ‚îÇ Tickets: 2        ‚îÇ   ‚îÇ              ‚îÇ
    ‚îÇ Health: 58%       ‚îÇ   ‚îÇ              ‚îÇ
    ‚îÇ Churn: 68%        ‚îÇ   ‚îÇ              ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ              ‚îÇ
              ‚îÇ              ‚îÇ              ‚îÇ
              ‚Üì              ‚Üì              ‚Üì
         Description    Description    Description
         Generated      Generated      Generated
              ‚îÇ              ‚îÇ              ‚îÇ
              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                             ‚Üì
                    Sorted by Risk √ó LTV
                             ‚Üì
                    Top 5-10 Selected
                             ‚Üì
                    Sent to Agent Pipeline
```

### Key Points:

1. **Data loaded once:** When program starts (singleton pattern)
2. **Calculations done on-demand:** When processing each customer
3. **Results NOT stored:** Just passed to next step
4. **Memory efficient:** Only keep dataframes + current customer analysis

---

## üìä Complete Step-by-Step with Code Locations

| Step  | Description              | Code Location                   | Data Used                                         | Output                 |
| ----- | ------------------------ | ------------------------------- | ------------------------------------------------- | ---------------------- |
| 1     | Load customers           | `data_analytics.py` line 49     | `customers` sheet                                 | `self.df` (1,000 rows) |
| 2a    | Fetch orders             | `data_analytics.py` line 702    | `orders` sheet filtered by `customer_id`          | Order stats dict       |
| 2b    | Fetch tickets            | `data_analytics.py` line 775    | `support_tickets` sheet filtered by `customer_id` | Ticket stats dict      |
| 2c    | Fetch NPS                | `data_analytics.py` line 817    | `nps_survey` sheet filtered by `customer_id`      | NPS dict               |
| 2d    | Fetch payments           | `data_analytics.py` line 853    | `payments` sheet filtered by `customer_id`        | Payment stats dict     |
| 3     | Calculate health         | `proactive_monitor.py` line 16  | Results from step 2                               | Health score (0-1)     |
| 4     | Calculate churn          | `proactive_monitor.py` line 144 | Health score + `churn_labels`                     | Churn risk (0-1)       |
| 5     | Filter at-risk           | `proactive_monitor.py` line 281 | Health + churn results                            | Filtered list          |
| 6     | Sort by priority         | `proactive_monitor.py` line 334 | Alert objects                                     | Sorted list            |
| **7** | **Generate description** | **`main.py` line 204**          | **Customer + alert**                              | **Description string** |
| 8     | Agent pipeline           | `main.py` line 294              | Description + customer                            | Agent decisions        |
| 9     | Display results          | `main.py` line 300              | Agent response                                    | Console output         |

---

## üéØ Summary Answers

### Q1: How does Step 7 generate descriptions?

**A:** Combines customer profile + health scores + risk factors + business logic into a formatted string

### Q2: Is Step 7 different from previous description?

**A:** YES! Step 7 = technical summary for AI agents. Step 9 = empathetic message for customers.

### Q3: Should datasheet have description?

**A:** NO! Description is generated dynamically by analyzing raw data. No "description" column in Excel.

### Q4: How do we fetch from multiple sheets?

**A:** Filter each DataFrame by `customer_id` using Pandas. All sheets have `customer_id` as foreign key.

### Q5: Where are comparisons stored?

**A:** IN-MEMORY only! Calculations happen at runtime, results not stored permanently. Just passed to next step.

---

## üí° Key Insight

**The system doesn't store comparisons - it's a PIPELINE:**

```
Raw Data ‚Üí Load ‚Üí Filter ‚Üí Calculate ‚Üí Generate ‚Üí Process ‚Üí Output
(Excel)   (Pandas) (by ID)  (health)   (descrip)  (agents)  (message)
```

Each step feeds the next, nothing is permanently stored except the original Excel data!
